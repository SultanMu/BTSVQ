function [posteriors, posteriors_class] = gmm_em_prob_classifier3(mix1,mix2,X1,X2,X)

% [PCX7,PCX7_class] = gmm_em_prob_classifier (mix_7_N_recur,mix_7_N_norecur,sM7_recur.codebook, sM7_norecur.codebook, sM7.codebook)

% Finds the posterior probablities of the codebook vector using the parameters of mix1
% and mix2. The parameters of mix1 and mix2 are generated by assuming one gaussian per
% data vector and finding its means and variences using EM algorithm. Then these parameters
% are used to classify a new vector.
% This function uses, dcEMGMM, gmm(from Netlab)

% mix1 & mix2 = generated by dcEMGMM (.....)
% X1 = sM7_recur.codebook
% X2 = sM7_no_recur.codebook
% X = sM_combined.codebook

% psteriors =  matrix of two columns 
%              the posteriors of the vector x interms of X1 and X2

% psteriors_class =  matrix of two columns 
%                  lists 1 for class X1 and 0 for class 2

N = length(X); 
R = (length(X1) + length(X2)); 
% Compute prior probability of each class 
PC1 = length(X1)/R; 
PC2 = 1-PC1; 
%load Parameter values obtained after cross validation 
%load lung7_2500 
Mu1 = mix1.centres; 
Sx1 = mix1.covars; 
Sy1 = mix1.covars; 
Ppr1 = mix1.priors; 
%clear Mu Sigma_x Sigma_y Pprior 
%load ParamC2 
Mu2 = mix2.centres; 
Sx2 = mix2.covars; 
Sy2 = mix2.covars; 
Ppr2 = mix2.priors; 

Mu = [Mu1 Mu2]; 
Sx = [Sx1 Sx2]; 
Sy = [Sy1 Sy2]; 
Ppr = [Ppr1 Ppr2]; 
d = 2; 
for n = 1:N 
	for j = 1:length(Mu1(:,1)) 
	pXC1(n,j) = 1/((2*pi)^(d/2)*Sx1(j)*Sy1(j))*exp(-1/2*(((X(n,:)-Mu1(j,:))/Sx1(j))^2+((X(n,2)-Mu1(j,2))/Sy1(j))^2)); 
	end 
pD1(n) = pXC1(n,:)*Ppr1'; 
end 
for n = 1:N 
	for j = 1:length(Mu2(:,1)) 
	pXC2(n,j) = 1/((2*pi)^(d/2)*Sx2(j)*Sy2(j))*exp(-1/2*(((X(n,1)-Mu2(j,1))/Sx2(j))^2+((X(n,2)-Mu2(j,2))/Sy2(j))^2)); 
end 
pD2(n) = pXC2(n,:)*Ppr2'; 
end 

% Compute posterior probabilities using Bayes Rule 
for ii = 1:N 
	PC1X(ii) = pD1(ii)*PC1/(pD1(ii)*PC1+pD2(ii)*PC2); 
end 
PC2X = 1-PC1X; 
PCX = [PC1X',PC2X']; 
posteriors = PCX;

% Classify 
num = 0; 
for j = 1:N 
	if PC1X(j) < 0.5 
		PC1X(j) = 0; 
		PC2X(j) = 1; 
		num = num + 1; 
	else 
		PC1X(j) = 1; 
		PC2X(j) = 0; 
	end 
end 
PCX_class = [PC1X', PC2X'];
posteriors_class = PCX_class;
%pause
%Per1 = num/N*100 
% Plot results 
%for ii = 1:length(Mu) 
%makeEllipse(Mu(ii,1),Mu(ii,2),2*Sx(ii),2*Sy(ii)) 
%hold on 
%end 
%plot(X(:,1),X(:,2),'+ k') 
%xlabel('x','fontsize',16) 
%ylabel('y','fontsize',16) 
%print -depsc ClassTest.eps 


